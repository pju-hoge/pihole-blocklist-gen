import sys
import os

def load_blocklist(filepath):
    domains = set()
    if not os.path.exists(filepath):
        return domains
    
    with open(filepath, 'r') as f:
        for line in f:
            parts = line.strip().split()
            # Expecting "0.0.0.0 domain.com" or just "domain.com"
            # Ignore comments
            if not parts or parts[0].startswith('#'):
                continue
            
            # If hosts format, take the last part
            if len(parts) >= 2 and parts[0] == '0.0.0.0':
                domain = parts[-1]
            else:
                domain = parts[0]
            
            # Basic normalization
            domain = domain.lower().strip('.')
            if domain:
                domains.add(domain)
    return domains

def optimize_domains(domains):
    # Optimizes the domain set by:
    # 1. Removing redundant children (e.g. remove a.example.com if example.com exists)
    # 2. Aggregating siblings (e.g. 1.fb.com, 2.fb.com, 3.fb.com -> fb.com)
    
    current_domains = set(domains)
    changed = True
    
    while changed:
        changed = False
        
        # --- Phase 1: Remove redundant children ---
        # Sort by reversed components to cluster families: com.example, com.example.sub
        r_list = ['.'.join(reversed(d.split('.'))) for d in current_domains]
        r_list.sort()
        
        clean_rev = []
        last_kept = None
        
        for r in r_list:
            if last_kept and (r == last_kept or r.startswith(last_kept + '.')):
                continue # Skip child
            last_kept = r
            clean_rev.append(r)
            
        optimized_set = set(['.'.join(reversed(r.split('.'))) for r in clean_rev])
        
        if len(optimized_set) != len(current_domains):
            current_domains = optimized_set
            changed = True
            
        # --- Phase 2: Aggregate Siblings ---
        parent_counts = {}
        for d in current_domains:
            if '.' in d:
                parts = d.split('.', 1)
                parent = parts[1]
                if '.' in parent: # Ensure parent is at least x.y (not just TLD)
                    parent_counts[parent] = parent_counts.get(parent, 0) + 1
        
        parents_to_add = set()
        for p, count in parent_counts.items():
            if count >= 3: # Threshold
                parents_to_add.add(p)
                
        if parents_to_add:
            old_len = len(current_domains)
            current_domains.update(parents_to_add)
            if len(current_domains) > old_len:
                changed = True
                # Loop will run Phase 1 again to remove children of newly added parents

    return current_domains

def main():
    blocklist_path = 'blocklist.txt'
    domains = load_blocklist(blocklist_path)
    
    if len(sys.argv) > 1:
        raw_new = sys.argv[1].lower().strip('.')
        # Basic validation regex for domain
        import re
        if raw_new and re.match(r'^[a-z0-9.-]+\.[a-z]{2,}$', raw_new):
            domains.add(raw_new)
        else:
            print(f"Skipping invalid domain input: {raw_new}")
            
    final_domains = optimize_domains(domains)
    
    with open(blocklist_path, 'w') as f:
        f.write("# Pi-hole Blocklist\n")
        f.write("# Generated by GitHub Action\n")
        f.write("# Format: 0.0.0.0 domain.com\n")
        for d in sorted(list(final_domains)):
            f.write(f"0.0.0.0 {d}\n")
            
    print(f"Processed {len(final_domains)} domains.")

if __name__ == "__main__":
    main()
